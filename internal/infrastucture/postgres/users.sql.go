// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: users.sql

package postgres

import (
	"context"

	. "air-line-reservation-backend/internal/infrastucture/postgres/model"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "users" (
    email, "password", phone, region, gender, title, first_name, last_name, age
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING user_id, email, password, phone, region, gender, title, first_name, last_name, create_at, update_at, age
`

type CreateUserParams struct {
	Email     string      `json:"email"`
	Password  string      `json:"password"`
	Phone     pgtype.Text `json:"phone"`
	Region    pgtype.Text `json:"region"`
	Gender    NullGender  `json:"gender"`
	Title     string      `json:"title"`
	FirstName string      `json:"first_name"`
	LastName  string      `json:"last_name"`
	Age       pgtype.Int2 `json:"age"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Password,
		arg.Phone,
		arg.Region,
		arg.Gender,
		arg.Title,
		arg.FirstName,
		arg.LastName,
		arg.Age,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.Region,
		&i.Gender,
		&i.Title,
		&i.FirstName,
		&i.LastName,
		&i.CreateAt,
		&i.UpdateAt,
		&i.Age,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "users" WHERE user_id = $1::uuid
`

func (q *Queries) DeleteUser(ctx context.Context, dollar_1 pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, dollar_1)
	return err
}

const getUsers = `-- name: GetUsers :one
SELECT user_id, email, password, phone, region, gender, title, first_name, last_name, create_at, update_at, age FROM "users"
WHERE email = $1 AND password = $2
`

type GetUsersParams struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) (User, error) {
	row := q.db.QueryRow(ctx, getUsers, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.Region,
		&i.Gender,
		&i.Title,
		&i.FirstName,
		&i.LastName,
		&i.CreateAt,
		&i.UpdateAt,
		&i.Age,
	)
	return i, err
}
