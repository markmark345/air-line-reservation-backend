
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>utils: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">air-line-reservation-backend/internal/domain/utils/random.go (100.0%)</option>
				
				<option value="file1">air-line-reservation-backend/internal/infrastucture/postgres/db.go (50.0%)</option>
				
				<option value="file2">air-line-reservation-backend/internal/infrastucture/postgres/model/models.go (61.5%)</option>
				
				<option value="file3">air-line-reservation-backend/internal/infrastucture/postgres/users.sql.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package utils

import (
        "math/rand"
        "strings"
        "time"
)

var randomGenerator = rand.New(rand.NewSource(time.Now().UnixNano()))

var charset = []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ")

func RandomInt(min, max int64) int64 <span class="cov8" title="1">{
        return randomGenerator.Int63n(max - min + 1) + min 
}</span>

func RandomString(n int) string <span class="cov8" title="1">{
        var sb strings.Builder
        k := len(charset)

        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                c := charset[randomGenerator.Intn(k)]
                sb.WriteByte(c)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

func RandomGender() string <span class="cov8" title="1">{
        gender := []string{"M", "F", "N"}
        n := len(gender)
        return gender[randomGenerator.Intn(n)]
}</span>

func RandomEmail() string <span class="cov8" title="1">{
        username := RandomString(8)
        domain := "gmail.com"
        return username + "@" + domain
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1

package postgres

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1

package model

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type Gender string

const (
        GenderM Gender = "M"
        GenderF Gender = "F"
        GenderN Gender = "N"
)

func (e *Gender) Scan(src interface{}) error <span class="cov8" title="1">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = Gender(s)</span>
        case string:<span class="cov8" title="1">
                *e = Gender(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for Gender: %T", src)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type NullGender struct {
        Gender Gender `json:"gender"`
        Valid  bool   `json:"valid"` // Valid is true if Gender is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGender) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                ns.Gender, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov8" title="1">ns.Valid = true
        return ns.Gender.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullGender) Value() (driver.Value, error) <span class="cov8" title="1">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return string(ns.Gender), nil</span>
}

type Role struct {
        RoleID   int32              `json:"role_id"`
        RoleName string             `json:"role_name"`
        CreateAt pgtype.Timestamptz `json:"create_at"`
}

type User struct {
        UserID    pgtype.UUID        `json:"user_id"`
        Email     string             `json:"email"`
        Password  string             `json:"password"`
        Phone     pgtype.Text        `json:"phone"`
        Region    pgtype.Text        `json:"region"`
        Gender    NullGender         `json:"gender"`
        Title     string             `json:"title"`
        FirstName string             `json:"first_name"`
        LastName  string             `json:"last_name"`
        CreateAt  pgtype.Timestamptz `json:"create_at"`
        UpdateAt  pgtype.Timestamptz `json:"update_at"`
        Age       pgtype.Int2        `json:"age"`
}

type UserAddress struct {
        AddressID int32              `json:"address_id"`
        UserID    pgtype.UUID        `json:"user_id"`
        Address   pgtype.Text        `json:"address"`
        CreateAt  pgtype.Timestamptz `json:"create_at"`
        UpdateAt  pgtype.Timestamptz `json:"update_at"`
}

type UserRole struct {
        UserID          pgtype.UUID        `json:"user_id"`
        Role            int32              `json:"role"`
        RoleDescription pgtype.Text        `json:"role_description"`
        CreateAt        pgtype.Timestamptz `json:"create_at"`
        UpdateAt        pgtype.Timestamptz `json:"update_at"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: users.sql

package postgres

import (
        "context"


        . "air-line-reservation-backend/internal/infrastucture/postgres/model"
        "github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "users" (
    email, "password", phone, region, gender, title, first_name, last_name, age
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING user_id, email, password, phone, region, gender, title, first_name, last_name, create_at, update_at, age
`

type CreateUserParams struct {
        Email     string      `json:"email"`
        Password  string      `json:"password"`
        Phone     pgtype.Text `json:"phone"`
        Region    pgtype.Text `json:"region"`
        Gender    NullGender  `json:"gender"`
        Title     string      `json:"title"`
        FirstName string      `json:"first_name"`
        LastName  string      `json:"last_name"`
        Age       pgtype.Int2 `json:"age"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createUser,
                arg.Email,
                arg.Password,
                arg.Phone,
                arg.Region,
                arg.Gender,
                arg.Title,
                arg.FirstName,
                arg.LastName,
                arg.Age,
        )
        var i User
        err := row.Scan(
                &amp;i.UserID,
                &amp;i.Email,
                &amp;i.Password,
                &amp;i.Phone,
                &amp;i.Region,
                &amp;i.Gender,
                &amp;i.Title,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.CreateAt,
                &amp;i.UpdateAt,
                &amp;i.Age,
        )
        return i, err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "users" WHERE user_id = $1::uuid
`

func (q *Queries) DeleteUser(ctx context.Context, dollar_1 pgtype.UUID) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteUser, dollar_1)
        return err
}</span>

const getUsers = `-- name: GetUsers :one
SELECT user_id, email, password, phone, region, gender, title, first_name, last_name, create_at, update_at, age FROM "users"
WHERE email = $1 AND password = $2
`

type GetUsersParams struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getUsers, arg.Email, arg.Password)
        var i User
        err := row.Scan(
                &amp;i.UserID,
                &amp;i.Email,
                &amp;i.Password,
                &amp;i.Phone,
                &amp;i.Region,
                &amp;i.Gender,
                &amp;i.Title,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.CreateAt,
                &amp;i.UpdateAt,
                &amp;i.Age,
        )
        return i, err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
